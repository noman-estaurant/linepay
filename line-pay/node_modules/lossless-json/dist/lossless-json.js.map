{"version":3,"file":"lossless-json.js","sources":["../lib/config.js","../lib/LosslessNumber.js","../lib/revive.js","../lib/pointer.js","../lib/parse.js","../lib/stringify.js"],"sourcesContent":["\nlet circularRefs = true;\n\n/**\n * Get and/or set configuration options\n * @param {{circularRefs: boolean}} [options]\n * @retrun {{circularRefs: boolean}}\n */\nexport function config (options) {\n  if (options) {\n    if (options.circularRefs != undefined) {\n      circularRefs = (options.circularRefs === true);\n    }\n  }\n\n  return { circularRefs }\n}\n","'use strict';\n\n/**\n * A lossless number. Stores it's value as string\n * @param {string | number} value\n * @constructor\n */\nexport class LosslessNumber {\n  constructor (value) {\n    // value as string\n    this.value = valueToString(value);\n\n    // type information\n    this.type = 'LosslessNumber';\n    this.isLosslessNumber = true;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number.\n   * Will throw an error when this conversion would result in a truncation\n   * of the number.\n   * @return {Number}\n   */\n  valueOf () {\n    let number = parseFloat(this.value);\n    let digits = getDigits(this.value);\n\n    // throw an error when the numeric value will lose information\n    if (digits.length > 15) {\n      throw new Error('Cannot convert to number: ' +\n          'number would be truncated (value: ' + this.value + ')');\n    }\n    if (!isFinite(number)) {\n      throw new Error('Cannot convert to number: number would overflow (value: ' + this.value + ')');\n    }\n    if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n      throw new Error('Cannot convert to number: number would underflow (value: ' + this.value + ')');\n    }\n\n    return number;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   * @return {string}\n   */\n  toString() {\n    return this.value;\n  }\n\n}\n\n/**\n * Convert input value to a string\n * If value is no number or string, the valueOf() of the object will be used.\n * @param {number | string} value\n * @return {string}\n */\nexport function valueToString (value) {\n  if (typeof value === 'string') {\n    if (!isValidNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value +'\")');\n    }\n\n    return value;\n  }\n  else if (typeof value === 'number') {\n    // validate number\n    if (getDigits(value + '').length > 15) {\n      throw new Error('Invalid number: contains more than 15 digits (value: ' + value + ')');\n    }\n    if (isNaN(value)) {\n      throw new Error('Invalid number: NaN');\n    }\n    if (!isFinite(value)) {\n      throw new Error('Invalid number: Infinity');\n    }\n\n    return value + '';\n  }\n  else {\n    return valueToString(value && value.valueOf());\n  }\n}\n\n/**\n * Parse a string into a number. When the value can be represented in a number,\n * the function returns a number. Else, the function returns a LosslessNumber\n * @param {string} value\n * @returns {LosslessNumber | number} Returns a number when the value fits\n *                                    in a regular number, else returns a\n *                                    LosslessNumber.\n */\nexport function createNumber (value) {\n  let digits = getDigits(value);\n\n  if (digits.length > 15) {\n    // would truncate digits\n    return new LosslessNumber(value);\n  }\n\n  let number = parseFloat(value);\n  if (!isFinite(number)) {\n    // overflow, finite or NaN\n    return new LosslessNumber(value);\n  }\n  else if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n    // underflow\n    return new LosslessNumber(value);\n  }\n  else {\n    return number;\n  }\n}\n\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.0034' returns '34'\n *   '120.5e+30' returns '1205'\n *\n * @param {number | string} value\n * @return {string} Returns the significant digits\n */\nexport function getDigits (value) {\n  let _value = (typeof value !== 'string') ? (value + '') : value;\n\n  return _value\n      .replace(/^-/, '')            // remove sign\n      .replace(/e.*$/, '')          // remove exponential notation\n      .replace( /^0\\.?0*|\\./, '');  // remove decimal point and leading zeros\n}\n\n/**\n * Test whether a string contains only zeros or is empty\n * @param {string} text\n * @return {boolean}\n */\nexport function containsOnlyZeros (text) {\n  return /^0*$/.test(text);\n}\n\n/**\n * Test whether a string contains a valid number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n * @param {string} value\n * @return {boolean}\n */\nexport function isValidNumber(value) {\n  return /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/.test(value);\n}\n","/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param {*} json   A JSON Object, Array, or value\n * @param {function (key: string, value: *)} reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n * @return {*}\n */\nexport function revive (json, reviver) {\n  return reviveValue({'': json}, '', json, reviver);\n}\n\n/**\n * Revive a value\n * @param {Object | Array} context\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *)} reviver\n * @return {*}\n */\nfunction reviveValue (context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  }\n  else if (value && typeof value === 'object' && !value.isLosslessNumber) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver))\n  }\n  else {\n    return reviver.call(context, key, value)\n  }\n}\n\n/**\n * Revive the properties of an object\n * @param {Object} object\n * @param {function} reviver\n * @return {Object}\n */\nfunction reviveObject (object, reviver) {\n  let revived = {};\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      revived[key] = reviveValue(object, key, object[key], reviver);\n    }\n  }\n\n  return revived;\n}\n\n/**\n * Revive the properties of an Array\n * @param {Array} array\n * @param {function} reviver\n * @return {Array}\n */\nfunction reviveArray (array, reviver) {\n  let revived = [];\n\n  for (let i = 0; i < array.length; i++) {\n    revived[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n\n  return revived;\n}\n","// JavaScript Object Notation (JSON) Pointer\n// https://tools.ietf.org/html/rfc6901\n\n/**\n * Escape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function escape (str) {\n  return encodeURIComponent(str\n      .replace(/\\//g, '~1')\n      .replace(/~/g, '~0'));\n}\n\n/**\n * Unescape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function unescape (str) {\n  return decodeURIComponent(str)\n      .replace(/~1/g, '/')\n      .replace(/~0/g, '~');\n}\n\n/**\n * Stringify an array of keys as a JSON Pointer URI fragment\n *\n * Example:\n *\n *     stringify(['foo', 'bar'])     // returns '#/foo/bar'\n *     stringify(['foo bar', 'baz']) // returns '#/foo%20bar/baz'\n *\n * @param {Array.<string>} array\n * @returns {string}\n */\nexport function stringify(array) {\n  return '#/' + array.map(escape).join('/');\n}\n\n/**\n * Parse a JSON Pointer URI fragment\n * @param {string} pointer\n * @return {Array.<string>}\n */\nexport function parse(pointer) {\n  let array = pointer.split('/').map(unescape);\n\n  // remove the hash\n  let hash = array.shift();\n  if (hash !== '#') {\n    throw SyntaxError('Cannot parse JSON Pointer: no valid URI fragment');\n  }\n\n  // remove last empty entry\n  if (array[array.length - 1] === '') {\n    array.pop();\n  }\n\n  return array;\n}\n","'use strict';\n\nimport { config } from './config';\nimport { LosslessNumber } from './LosslessNumber';\nimport { revive } from './revive';\nimport { parse as parsePointer } from './pointer';\n\n// token types enumeration\nconst TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  NUMBER: 2,\n  STRING: 3,\n  SYMBOL: 4,\n  UNKNOWN: 5\n};\n\n// map with all delimiters\nconst DELIMITERS = {\n  '': true,\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ':': true,\n  ',': true\n};\n\n// map with all escape characters\nconst ESCAPE_CHARACTERS = {\n  '\\\"': '\\\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  // \\u is handled by getToken()\n};\n\nlet jsonText = '';                // current json text\nlet index = 0;                    // current index in text\nlet c = '';                       // current token character in text\nlet token = '';                   // current token\nlet tokenType = TOKENTYPE.NULL;   // type of current token\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * @param {string} text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param {function(key: string, value: *)} [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse (text, reviver) {\n  // initialize\n  jsonText = text;\n  index = 0;\n  c = jsonText.charAt(0);\n  token = '';\n  tokenType = TOKENTYPE.NULL;\n\n  // clear stack\n  stack = [];\n  path = [];\n\n  // get first token\n  getToken();\n\n  // parse everything\n  let json = parseObject();\n\n  if (token != '') {\n    throw createSyntaxError('Unexpected characters');\n  }\n\n  return reviver ? revive(json, reviver) : json;\n}\n\n/**\n * Get the next character from the expression.\n * The character is stored into the char c. If the end of the expression is\n * reached, the function puts an empty string in c.\n * @private\n */\nfunction next() {\n  index++;\n  c = jsonText.charAt(index);\n}\n\n/**\n * Get next token in the current text.\n * The token and token type are available as token and tokenType\n * @private\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = '';\n\n  // skip over whitespaces: space, tab, newline, and carriage return\n  while (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') {\n    next();\n  }\n\n  // check for delimiters\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for a number\n  if (isDigit(c) || c == '-') {\n    tokenType = TOKENTYPE.NUMBER;\n\n    if (c == '-') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n    }\n    else if (c == '0') {\n      token += c;\n      next();\n    }\n    else {\n      // digit 1-9, nothing extra to do\n    }\n\n    while (isDigit(c)) {\n      token += c;\n      next();\n    }\n\n    if (c == '.') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    if (c == 'e' || c == 'E') {\n      token += c;\n      next();\n\n      if (c == '+' || c == '-') {\n        token += c;\n        next();\n      }\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    return;\n  }\n\n  // check for a string\n  if (c == '\"') {\n    tokenType = TOKENTYPE.STRING;\n    next();\n\n    while (c != '' && c != '\"') {\n\n      if (c == '\\\\') {\n        // handle escape characters\n        next();\n\n        let unescaped = ESCAPE_CHARACTERS[c];\n        if (unescaped !== undefined) {\n          token += unescaped;\n          next();\n        }\n        else if (c == 'u') {\n          // parse escaped unicode character, like '\\\\u260E'\n          next();\n\n          let hex = '';\n          for (let u = 0; u < 4; u++) {\n            if (!isHex(c)) {\n              throw createSyntaxError('Invalid unicode character');\n            }\n            hex += c;\n            next();\n          }\n\n          token += String.fromCharCode(parseInt(hex, 16));\n        }\n        else {\n          throw createSyntaxError('Invalid escape character \"\\\\' + c + '\"', index);\n        }\n      }\n      else {\n        // a regular character\n        token += c;\n        next();\n      }\n    }\n\n    if (c != '\"') {\n      throw createSyntaxError('End of string expected');\n    }\n    next();\n\n    return;\n  }\n\n  // check for symbols (true, false, null)\n  if (isAlpha(c)) {\n    tokenType = TOKENTYPE.SYMBOL;\n\n    while (isAlpha(c)) {\n      token += c;\n      next();\n    }\n\n    return;\n  }\n\n  // something unknown is found, wrong characters -> a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c != '') {\n    token += c;\n    next();\n  }\n  throw createSyntaxError('Syntax error in part \"' + token + '\"');\n}\n\n/**\n * Check if the given character contains an alpha character, a-z, A-Z, _\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isAlpha (c) {\n  return /^[a-zA-Z_]/.test(c);\n}\n\n/**\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isHex (c) {\n  return /^[0-9a-fA-F]/.test(c);\n}\n\n/**\n * checks if the given char c is a digit\n * @param {string} c   a string with one character\n * @return {boolean}\n * @private\n */\nfunction isDigit (c) {\n  return (c >= '0' && c <= '9');\n}\n\n/**\n * Create an error\n * @param {string} message\n * @param {number} [c]  Optional index (character position) where the\n *                      error happened. If not provided, the start of\n *                      the current token is taken\n * @return {SyntaxError} instantiated error\n * @private\n */\nfunction createSyntaxError (message, c) {\n  if (c === undefined) {\n    c = index - token.length;\n  }\n  let error = new SyntaxError(message + ' (char ' + c + ')');\n  error['char'] = c;\n\n  return error;\n}\n\n/**\n * Parse an object like '{\"key\": \"value\"}'\n * @return {*}\n */\nfunction parseObject () {\n  if (token == '{') {\n    getToken();\n\n    let key;\n    let object = {};\n\n    if (token == '}') {\n      // empty object\n      getToken();\n      return object;\n    }\n\n    // add this object to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = object;\n\n    while (true) {\n      // parse key\n      if (tokenType != TOKENTYPE.STRING) {\n        throw createSyntaxError('Object key expected');\n      }\n      key = token;\n      getToken();\n\n      // parse key/value separator\n      if (token != ':') {\n        throw createSyntaxError('Colon expected');\n      }\n      getToken();\n\n      // parse value\n      path[stackIndex] = key;\n      object[key] = parseObject();\n\n      // parse key/value pair separator\n      if (token != ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (token != '}') {\n      throw createSyntaxError('Comma or end of object \"}\" expected');\n    }\n    getToken();\n\n    // check whether this is a circular reference\n    if (isCircular(object)) {\n      return parseCircular(object);\n    }\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return object;\n  }\n\n  return parseArray();\n}\n\n/**\n * Parse an object like '[\"item1\", \"item2\", ...]'\n * @return {*}\n */\nfunction parseArray () {\n  if (token == '[') {\n    getToken();\n\n    let array = [];\n\n    if (token == ']') {\n      // empty array\n      getToken();\n      return array;\n    }\n\n    // add this array to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = array;\n\n    while (true) {\n      // parse item\n      path[stackIndex] = array.length + '';\n      array.push(parseObject());\n\n      // parse item separator\n      if (token != ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (token != ']') {\n      throw createSyntaxError('Comma or end of array \"]\" expected');\n    }\n    getToken();\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return array;\n  }\n\n  return parseString();\n}\n\n/**\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n * @return {*}\n */\nfunction parseString () {\n  if (tokenType == TOKENTYPE.STRING) {\n    let str = token;\n    getToken();\n    return str;\n  }\n\n  return parseNumber();\n}\n\n/**\n * Parse a number. The number will be parsed as a LosslessNumber.\n * @return {*}\n */\nfunction parseNumber () {\n  if (tokenType == TOKENTYPE.NUMBER) {\n    let number = new LosslessNumber(token);\n    getToken();\n    return number;\n  }\n\n  return parseSymbol();\n}\n\n/**\n * Parse constants true, false, null\n * @return {boolean | null}\n */\nfunction parseSymbol () {\n  if (tokenType == TOKENTYPE.SYMBOL) {\n    if (token === 'true') {\n      getToken();\n      return true;\n    }\n    if (token === 'false') {\n      getToken();\n      return false;\n    }\n    if (token === 'null') {\n      getToken();\n      return null;\n    }\n\n    throw createSyntaxError('Unknown symbol \"' + token + '\"');\n  }\n\n  return parseEnd();\n}\n\n/**\n * Evaluated when the expression is not yet ended but expected to end\n */\nfunction parseEnd () {\n  if (token == '') {\n    // syntax error or unexpected end of expression\n    throw createSyntaxError('Unexpected end of json string');\n  } else {\n    throw createSyntaxError('Value expected');\n  }\n}\n\n/**\n * Test whether an object is a circular reference, like {$ref: '#/foo/bar'}\n * @param {Object} object\n * @return {boolean}\n */\nfunction isCircular (object) {\n  return typeof object.$ref === 'string' && Object.keys(object).length === 1;\n}\n\n/**\n * Resolve a circular reference.\n * Throws an error if the path cannot be resolved\n * @param {Object} object    An object with a JSON Pointer URI fragment\n *                           like {$ref: '#/foo/bar'}\n * @return {Object | Array}\n */\nfunction parseCircular(object) {\n  // if circular references are disabled, just return the refs object\n  if (!config().circularRefs) {\n    return object;\n  }\n\n  let pointerPath = parsePointer(object.$ref);\n\n  // validate whether the path corresponds with current stack\n  for (let i = 0; i < pointerPath.length; i++) {\n    if (pointerPath[i] !== path[i]) {\n      throw new Error('Invalid circular reference \"' +  object.$ref + '\"');\n    }\n  }\n\n  return stack[pointerPath.length];\n}\n","'use strict';\n\nimport { config } from './config'\nimport { stringify as stringifyPointer } from './pointer';\n\n// map with control characters to be escaped\nconst CONTROL_CHARACTERS = {\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n};\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param {*} value\n * The value to convert to a JSON string.\n *\n * @param {function(key: string, value: *) | Array.<string | number>} [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param {number | string} [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @returns {string | undefined} Returns the string representation of the JSON object.\n */\nexport function stringify(value, replacer, space) {\n  // clear stack\n  stack = [];\n  path = [];\n\n  let _value = (typeof replacer === 'function')\n      ? replacer.call({'': value}, '', value)\n      : value;\n\n  let _space; // undefined by default\n  if (typeof space === 'number') {\n    if (space > 10) {\n      _space = repeat(' ', 10);\n    }\n    else if (space >= 1) {\n      _space = repeat(' ', space);\n    }\n    // else ignore\n  }\n  else if (typeof space === 'string' && space !== '') {\n    _space = space;\n  }\n\n  return stringifyValue(_value, replacer, _space, '');\n}\n\n/**\n * Stringify a value\n * @param {*} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string | undefined}\n */\nfunction stringifyValue(value, replacer, space, indent) {\n  // boolean\n  if (value === true || value === false || value instanceof Boolean) {\n    return value + '';\n  }\n\n  // null\n  if (value === null) {\n    return 'null';\n  }\n\n  // number\n  if (typeof value === 'number' || value instanceof Number) {\n    if (isNaN(value) || !isFinite(value)) {\n      return 'null';\n    }\n    return value + '';\n  }\n\n  // lossless number, the secret ingredient :)\n  if (value && value.isLosslessNumber) {\n    return value.value;\n  }\n\n  // string\n  if (typeof value === 'string' || value instanceof String) {\n    let escaped = '';\n\n    for (let i = 0; i < value.length; i++) {\n      let c = value[i];\n      escaped += CONTROL_CHARACTERS[c] || c;\n    }\n\n    return '\"' + escaped + '\"';\n  }\n\n  // date\n  if (value instanceof Date) {\n    return '\"' + value.toISOString() + '\"';\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return stringifyArray(value, replacer, space, indent);\n  }\n\n  // object (test lastly!)\n  if (value && typeof value === 'object') {\n    return stringifyObject(value, replacer, space, indent);\n  }\n\n  return undefined;\n}\n\n/**\n * Stringify an array\n * @param {Array} array\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyArray(array, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let str = space ? '[\\n' : '[';\n\n  // check for circular reference\n  if (isCircular(array)) {\n    return stringifyCircular(array, replacer, space, indent);\n  }\n\n  // add this array to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = array;\n\n  for (let i = 0; i < array.length; i++) {\n    let key = i + '';\n    let item = (typeof replacer === 'function')\n        ? replacer.call(array, key, array[i])\n        : array[i];\n\n    if (space) {\n      str += childIndent;\n    }\n\n    if (typeof item !== 'undefined' && typeof item !== 'function') {\n      path[stackIndex] = key;\n      str += stringifyValue(item, replacer, space, childIndent);\n    }\n    else {\n      str += 'null'\n    }\n\n    if (i < array.length - 1) {\n      str += space ? ',\\n' : ',';\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + ']') : ']';\n  return str;\n}\n\n/**\n * Stringify an object\n * @param {Object} object\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyObject(object, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let first = true;\n  let str = space ? '{\\n' : '{';\n\n  if (typeof object.toJSON === 'function') {\n    return stringify(object.toJSON(), replacer, space);\n  }\n\n  // check for circular reference\n  if (isCircular(object)) {\n    return stringifyCircular(object, replacer, space, indent);\n  }\n\n  // add this object to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = object;\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      let value = (typeof replacer === 'function')\n          ? replacer.call(object, key, object[key])\n          : object[key];\n\n      if (includeProperty(key, value, replacer)) {\n        if (first) {\n          first = false;\n        }\n        else {\n          str += space ? ',\\n' : ',';\n        }\n\n        str += space\n          ? (childIndent + '\"' + key + '\": ')\n          : ('\"' + key + '\":');\n\n        path[stackIndex] = key;\n        str += stringifyValue(value, replacer, space, childIndent);\n      }\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + '}') : '}';\n  return str;\n}\n\n/**\n * Test whether an object or array is a circular reference\n * @param {Object | Array} value\n * @return {boolean}\n */\nfunction isCircular(value) {\n  return stack.indexOf(value) !== -1;\n}\n\n/**\n * Stringify a circular reference\n * @param {Object | Array} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyCircular (value, replacer, space, indent) {\n  if (!config().circularRefs) {\n    throw new Error('Circular reference at \"' + stringifyPointer(path) + '\"');\n  }\n\n  let pathIndex = stack.indexOf(value);\n\n  let circular = {\n    $ref: stringifyPointer(path.slice(0, pathIndex))\n  };\n\n  return stringifyObject(circular, replacer, space, indent);\n}\n\n/**\n * Test whether to include a property in a stringified object or not.\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *) | Array<string | number>} [replacer]\n * @return {boolean}\n */\nfunction includeProperty (key, value, replacer) {\n  return typeof value !== 'undefined'\n      && typeof value !== 'function'\n      && (!Array.isArray(replacer) || contains(replacer, key));\n}\n\n/**\n * Check whether an array contains some value.\n * Uses a non-strict comparison, so contains([1,2,3], '2') returns true\n * @param {Array} array\n * @param {*} value\n * @return {boolean}\n */\nfunction contains(array, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] == value) { // non-strict equality check!\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Repeat a string a number of times.\n * Simple linear solution, we only need up to 10 iterations in practice\n * @param {string} text\n * @param {number} times\n * @return {string}\n */\nfunction repeat (text, times) {\n  let res = '';\n  while (times-- > 0) {\n    res += text;\n  }\n  return res;\n}\n"],"names":["config","options","undefined","circularRefs","valueToString","value","isValidNumber","Error","getDigits","length","isNaN","isFinite","valueOf","replace","containsOnlyZeros","text","test","revive","json","reviver","reviveValue","context","key","Array","isArray","call","reviveArray","isLosslessNumber","reviveObject","object","revived","hasOwnProperty","array","i","escape","str","encodeURIComponent","unescape","decodeURIComponent","stringify","map","join","parse","pointer","split","shift","SyntaxError","pop","next","jsonText","charAt","index","getToken","TOKENTYPE","NULL","c","DELIMITERS","DELIMITER","isDigit","NUMBER","createSyntaxError","isAlpha","UNKNOWN","token","SYMBOL","STRING","unescaped","ESCAPE_CHARACTERS","hex","u","isHex","String","fromCharCode","parseInt","message","error","parseObject","stackIndex","stack","tokenType","isCircular","parseCircular","parseArray","push","parseString","parseNumber","number","LosslessNumber","parseSymbol","parseEnd","$ref","Object","keys","pointerPath","parsePointer","path","replacer","space","_value","_space","repeat","stringifyValue","indent","Boolean","Number","escaped","CONTROL_CHARACTERS","Date","toISOString","stringifyArray","stringifyObject","childIndent","stringifyCircular","item","first","toJSON","includeProperty","indexOf","stringifyPointer","pathIndex","slice","contains","times","res","type","parseFloat","this","digits","Math","abs","MIN_VALUE"],"mappings":"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"}